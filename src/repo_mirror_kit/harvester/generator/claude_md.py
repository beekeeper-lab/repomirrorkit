"""CLAUDE.md generator.

Generates the main CLAUDE.md project instructions file from surfaces,
detected stack profile, and project metadata. Follows the structure of
a proven Claude Code project CLAUDE.md: header, tech stack, safety rules,
quality rules, team roster, and workflow references.
"""

from __future__ import annotations

from repo_mirror_kit.harvester.analyzers.surfaces import SurfaceCollection
from repo_mirror_kit.harvester.detectors.base import StackProfile


def generate_claude_md(
    project_name: str,
    surfaces: SurfaceCollection,
    profile: StackProfile,
    agents: list[dict[str, str]],
    stack_files: list[str],
) -> str:
    """Generate CLAUDE.md content from harvest data.

    Args:
        project_name: Name of the analyzed project.
        surfaces: All extracted surfaces.
        profile: Detected technology stack profile.
        agents: List of agent dicts with 'name', 'file', 'description' keys.
        stack_files: List of generated stack convention file paths.

    Returns:
        Complete CLAUDE.md content as a string.
    """
    sections: list[str] = []

    sections.append(_render_header(project_name, profile))
    sections.append(_render_stack_reference(profile, surfaces))
    sections.append(_render_safety_rules(surfaces))
    sections.append(_render_quality_rules())
    sections.append(_render_team_roster(agents))
    sections.append(_render_workflow_reference(stack_files))

    return "\n".join(sections)


def _render_header(project_name: str, profile: StackProfile) -> str:
    """Render the CLAUDE.md header with project name and tech stack summary."""
    stacks = sorted(profile.stacks.keys())
    tech_line = ", ".join(stacks) if stacks else "unknown"
    return f"""# {project_name}

A Claude Code project folder generated by RepoMirrorKit from analysis of the original codebase.

**Tech stack:** {tech_line}

---"""


def _render_stack_reference(
    profile: StackProfile,
    surfaces: SurfaceCollection,
) -> str:
    """Render the Stack Quick Reference section."""
    lines: list[str] = ["\n## Stack Quick Reference\n"]

    stacks = sorted(profile.stacks.keys())
    if not stacks:
        lines.append("No technology stacks were detected.\n")
        return "\n".join(lines)

    # Build a concern/tool table from detected stacks and surfaces
    concerns: list[tuple[str, str]] = []

    # Detect primary language
    lang = _detect_primary_language(stacks)
    if lang:
        concerns.append(("Primary language", lang))

    # Detect frameworks
    frameworks = [s for s in stacks if s not in _LANGUAGE_STACKS]
    if frameworks:
        concerns.append(("Framework(s)", ", ".join(sorted(frameworks))))

    # Detect test framework from surfaces
    test_frameworks = _extract_test_frameworks(surfaces)
    if test_frameworks:
        concerns.append(("Test framework", ", ".join(sorted(test_frameworks))))

    # Detect build/deploy tools
    build_tools = _extract_build_tools(surfaces)
    if build_tools:
        concerns.append(("Build/deploy", ", ".join(sorted(build_tools))))

    # Detect package managers from dependencies
    pkg_managers = _extract_package_managers(surfaces)
    if pkg_managers:
        concerns.append(("Package manager", ", ".join(sorted(pkg_managers))))

    if concerns:
        lines.append("| Concern | Tool / Technology |")
        lines.append("|---------|-------------------|")
        for concern, tool in concerns:
            lines.append(f"| {concern} | {tool} |")
    else:
        lines.append("| Concern | Tool / Technology |")
        lines.append("|---------|-------------------|")
        for stack in stacks:
            lines.append(f"| Detected stack | {stack} |")

    lines.append("")
    return "\n".join(lines)


_LANGUAGE_STACKS = frozenset(
    {
        "python",
        "javascript",
        "typescript",
        "go",
        "dotnet",
        "csharp",
        "ruby",
        "java",
        "rust",
    }
)


def _detect_primary_language(stacks: list[str]) -> str:
    """Detect the primary language from stack names."""
    for stack in stacks:
        if stack in _LANGUAGE_STACKS:
            return stack
    return ""


def _extract_test_frameworks(surfaces: SurfaceCollection) -> set[str]:
    """Extract unique test frameworks from test pattern surfaces."""
    frameworks: set[str] = set()
    for tp in surfaces.test_patterns:
        if tp.framework:
            frameworks.add(tp.framework)
    return frameworks


def _extract_build_tools(surfaces: SurfaceCollection) -> set[str]:
    """Extract unique build/deploy tools from build_deploy surfaces."""
    tools: set[str] = set()
    for bd in surfaces.build_deploy:
        if bd.tool:
            tools.add(bd.tool)
    return tools


def _extract_package_managers(surfaces: SurfaceCollection) -> set[str]:
    """Extract package managers from dependency manifest files."""
    managers: set[str] = set()
    manifest_map = {
        "package.json": "npm/yarn",
        "pyproject.toml": "pip/uv",
        "requirements.txt": "pip",
        "Gemfile": "bundler",
        "go.mod": "go modules",
        "Cargo.toml": "cargo",
        "pom.xml": "maven",
        "build.gradle": "gradle",
    }
    for dep in surfaces.dependencies:
        for manifest, mgr in manifest_map.items():
            if manifest in dep.manifest_file:
                managers.add(mgr)
    return managers


def _render_safety_rules(surfaces: SurfaceCollection) -> str:
    """Render cross-cutting safety rules, customized to detected patterns."""
    rules: list[str] = [
        "1. **No secrets in code.** Never hardcode secrets, API keys, credentials, "
        "or connection strings in source code, configuration files, logs, or build "
        "artifacts. Inject at runtime from a secrets manager.",
        "2. **No PII in logs.** Never log personally identifiable information or "
        "sensitive data at any log level. Log redacted identifiers only.",
        "3. **Validate at boundaries.** Validate all external inputs at system "
        "boundaries -- user input, API responses, file contents. Do not trust "
        "internal assumptions about external data.",
        "4. **Least privilege.** Every component, user, and service account should "
        "have the minimum permissions needed.",
        "5. **Secure defaults.** Systems should be secure out of the box. Insecure "
        "configurations require explicit, documented opt-in.",
        "6. **No disabled safety checks.** Do not disable security features, "
        "linters, pre-commit hooks, or safety checks without explicit documented "
        "approval.",
    ]

    # Conditional rules based on detected surfaces
    if surfaces.auth:
        rules.append(
            "7. **Auth on every endpoint.** Every API endpoint and route must "
            "enforce authentication and authorization. Open endpoints require "
            "explicit documentation."
        )

    if surfaces.models:
        rules.append(
            f"{len(rules) + 1}. **Parameterize queries.** Never concatenate user "
            "input into SQL or query strings. Use parameterized queries or ORM "
            "methods exclusively."
        )

    if surfaces.dependencies:
        rules.append(
            f"{len(rules) + 1}. **Dependency discipline.** Adding a new dependency "
            "is a deliberate decision. Evaluate maintenance status, license "
            "compatibility, and security posture before adding."
        )

    lines = ["\n## Cross-Cutting Safety Rules\n"]
    lines.append("These apply to ALL personas, ALL tasks, without exception.\n")
    for rule in rules:
        lines.append(rule)
    lines.append("")

    return "\n".join(lines)


def _render_quality_rules() -> str:
    """Render cross-cutting quality rules (standard set)."""
    return """
## Cross-Cutting Quality Rules

These apply to ALL personas, ALL artifacts.

1. **Testability.** Every requirement, acceptance criterion, and behavior must be testable.
2. **Traceability.** Every requirement traces back to a stakeholder need. Every acceptance criterion traces forward to a test case.
3. **Error handling.** Errors should be visible, not swallowed. Use meaningful error messages. No bare except or silent failure patterns.
4. **Readability.** Code and documents are read far more often than written. Prefer explicit over clever.
5. **Small and incremental.** Deliver in thin, vertical slices. Small PRs, small stories, small merges.
6. **Decisions are recorded.** Every significant decision gets a documented rationale.
7. **No TODO without tracking.** No TODO comments without a linked issue.
8. **Convention over configuration.** Follow project conventions. Deviations require justification.
"""


def _render_team_roster(agents: list[dict[str, str]]) -> str:
    """Render the team roster table from generated agent metadata."""
    lines = ["\n## Team Roster\n"]

    if not agents:
        lines.append("No agents were generated.\n")
        return "\n".join(lines)

    lines.append("| Persona | Agent File |")
    lines.append("|---------|------------|")
    for agent in agents:
        lines.append(f"| {agent['name']} | `{agent['file']}` |")
    lines.append("")

    return "\n".join(lines)


def _render_workflow_reference(stack_files: list[str]) -> str:
    """Render the workflow reference section."""
    lines = ["\n## Workflow Reference\n"]
    lines.append("| Resource | Path | Purpose |")
    lines.append("|----------|------|---------|")
    lines.append(
        "| Surface map | `reports/surface-map.md` | "
        "Complete inventory of extracted surfaces |"
    )
    lines.append(
        "| Traceability | `reports/traceability/` | "
        "Cross-reference maps between surface types |"
    )
    lines.append(
        "| Coverage report | `reports/coverage.md` | "
        "Bean coverage metrics and gap analysis |"
    )
    lines.append(
        "| Generated beans | `beans/` | Individual requirement specifications |"
    )
    lines.append(
        "| Bean index | `beans/_index.md` | Master backlog of all generated beans |"
    )

    for sf in stack_files:
        lines.append(
            f"| Stack conventions | `{sf}` | Language and framework coding standards |"
        )

    lines.append("")
    return "\n".join(lines)
